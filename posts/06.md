---
title: "React Hooks: From â€˜What the Hook?!â€™ to Hooked for Life ðŸŽ£ðŸ˜‚"
subtitle: "The Journey Through useState, useRef, and useEffect"
date: "2024-11-26"
---
# React Hooks: From â€˜What the Hook?!â€™ to Hooked for Life ðŸŽ£ðŸ˜‚

When I first heard about React hooks, my brain was like, â€œHooks? Are we fishing in the code?â€ ðŸŽ£ But little did I know, these hooks would reel me into the world of React and never let go. This is the story of my love-hate relationship with three of the most iconic hooks: `useState`, `useRef`, and `useEffect`. Letâ€™s dive in and see how these buddies changed the way I codeâ€”forever.

---

## Act 1: `useState` - The Rollercoaster of Emotions ðŸŽ¢

The first hook I ever met was `useState`, and let me tell youâ€”itâ€™s like your emotional support system in React. Youâ€™re building an app, and suddenly you need to keep track of things like counters, toggles, or user inputs. Boom! In comes `useState`.

Hereâ€™s how I started:

```javascript
const [count, setCount] = useState(0);
```

I remember staring at this line for 15 minutes straight. â€œWhy are we destructuring? Where is this `setCount` coming from?!â€ It felt like React was speaking a language only aliens understood. ðŸ›¸

But once I figured it out, I felt like Iâ€™d unlocked a superpower. **Stateful components? No more class components? Just a single function call?** ðŸ¤¯

`useState` was my first crush, and letâ€™s be honestâ€”itâ€™s still my favorite. You want to toggle dark mode? Boom. Update a form value? Boom. You want to build a counter app just for the dopamine hit of watching the number go up? BAM!

```javascript
const [mood, setMood] = useState("ðŸ˜");

// Toggle mood
const toggleMood = () => setMood(mood === "ðŸ˜" ? "ðŸ˜„" : "ðŸ˜");
```

Itâ€™s like magicâ€”but youâ€™re the magician. ðŸŽ©âœ¨

---

## Act 2: `useRef` - The Silent Observer ðŸ‘€

Next up was `useRef`, and Iâ€™ll be honestâ€”this one didnâ€™t make sense at first. People told me, â€œItâ€™s used for accessing DOM elements or storing mutable values.â€

Me? I was like, â€œWhy canâ€™t I just use state for that?â€

Then I tried to manage a timer using `useState`. Spoiler alert: It was a disaster. The state kept re-rendering, and I felt like I was stuck in an infinite loop of despair. Thatâ€™s when `useRef` swooped in like a hero in a Tamil movie climax. ðŸŽ¥ðŸ”¥

```javascript
const timerRef = useRef(null);

const startTimer = () => {
  timerRef.current = setInterval(() => {
    console.log("Tick-tock â°");
  }, 1000);
};

const stopTimer = () => {
  clearInterval(timerRef.current);
  timerRef.current = null;
};
```

This was the moment I realized `useRef` isnâ€™t just a random sidekickâ€”itâ€™s the *quiet MVP*. It doesnâ€™t cause re-renders. Itâ€™s like the backstage crew of your app, making sure everything runs smoothly without stealing the spotlight.

---

## Act 3: `useEffect` - The Overachiever ðŸ˜…

Ah, `useEffect`â€”the one hook that made me question all my life choices. Everyone said, â€œItâ€™s for side effects.â€ I was like, â€œWhat even is a side effect?â€

For the first few weeks, I wrote `useEffect` like this:

```javascript
useEffect(() => {
  console.log("Component rendered!");
});
```

And then I kept wondering why my app behaved like it had a caffeine overdoseâ€”re-rendering endlessly. *"Why React, why?"* ðŸ˜­

Thatâ€™s when I learned about **dependencies**:

```javascript
useEffect(() => {
  console.log("This only runs when count changes!");
}, [count]);
```

It clicked. Suddenly, `useEffect` went from *annoying frenemy* to *lifesaver*. Need to fetch data? `useEffect`. Clean up event listeners? `useEffect`. Run a side effect when something changes? **USE. EFFECT.**

And letâ€™s not forget the cleanup functionâ€”itâ€™s like the nice friend who makes sure the party is over before everyone starts wrecking your house.

```javascript
useEffect(() => {
  const handleScroll = () => console.log("Scrolling!");

  window.addEventListener("scroll", handleScroll);
  
  return () => {
    window.removeEventListener("scroll", handleScroll);
  };
}, []);
```

Itâ€™s like having a bouncer for your events. No mess, no drama. ðŸ’ª

---

## How I Really Understood Hooks

At first, hooks felt like riddles wrapped in mysteries. But the more I used them, the more I realized theyâ€™re just toolsâ€”powerful tools that let you write clean, efficient React apps.

- **`useState`**: When you need to manage state. Itâ€™s the bread and butter of React.  
- **`useRef`**: When you need a mutable reference or access to the DOM without re-rendering.  
- **`useEffect`**: When you need to handle side effects like data fetching, subscriptions, or anything async.  

---

## Where Hooks Shine

Hooks are everywhere in React:

1. **Forms**: Managing input fields with `useState`.  
2. **Timers**: Using `useRef` to store interval IDs.  
3. **APIs**: Fetching data with `useEffect` and cleaning up subscriptions.  
4. **Custom Hooks**: Combine logic into reusable hooks.  

They make your code simpler, cleaner, and more readableâ€”like upgrading from a Nokia 1100 to an iPhone.

---

## Final Words

If React hooks seem confusing, donâ€™t worryâ€”youâ€™re not alone. They take time, but once you get it, youâ€™ll wonder how you ever lived without them.

And remember: Hooks arenâ€™t just a featureâ€”theyâ€™re a philosophy. They make your components simpler, your code cleaner, and your life easier. ðŸŽ‰

So, if you havenâ€™t embraced hooks yet, what are you waiting for? Go on, get *hooked*! ðŸ˜‰